definitions:
  # the names of the functions - we use this to generate the code and to register the functions in
  # the javascript class
  ifunction: "csx_${generator.prefix}_${class_name}_${func_name}"
  sfunction: "csx_${generator.prefix}_${class_name}_${func_name}"
  constructor: "csx_${generator.prefix}_${class_name}_constructor"
ctypes:
  # va_arg only support c types, so these type don't need to do convertion
  - bool
  - char
  - "signed char"
  - "unsigned char"
  - short
  - "short int"
  - "signed short"
  - "signed short int"
  - "unsigned short"
  - "unsigned short int"
  - int
  - "signed int"
  - unsigned
  - "unsigned int"
  - long
  - "long int"
  - "signed long"
  - "signed long int"
  - "unsigned long"
  - "unsigned long int"
  - "long long"
  - "long long int"
  - "signed long long"
  - "signed long long int"
  - "unsigned long long"
  - "unsigned long long int"
  - float
  - double
  - "long double"
conversions:
  # some times you want to use a special native type when converting from spidermonkey to native
  # the most common case would be from JS-boolean to bool. Using "bool" will fail here since we
  # pass the address to the conversion method, and a JSBool is defined as an integer in spidermonkey
  native_types:
    "@std::vector<std::basic_string.*>.>.>": "std::vector<std::string>"
    "@std::vector<int.*>.>": "std::vector<int>"
    "@cocos2d::Map<std::basic_string.*,": "cocos2d::Map<std::string,"
  to_native:
    # from binding to native
    "@Point": "cocos2d::Point ${in_value} = to_point(*va_arg(args, QPointF*))"
    "@Rect": "cocos2d::Rect ${in_value} = to_rect(*va_arg(args, QRectF*))"
    "@Size": "cocos2d::Size ${in_value} = to_size(*va_arg(args, QSizeF*))"
    "@Color4B": "cocos2d::Color4B ${in_value} = to_color4B(*va_arg(args, QColor*))"
    "@Color4F": "cocos2d::Color4F ${in_value} = to_color4F(*va_arg(args, QColor*))"
    "@Color3B": "cocos2d::Color3B ${in_value} = to_color3B(*va_arg(args, QColor*))"
    "@std::string": "std::string ${in_value} = (*va_arg(args, QString*)).toStdString()"
    "char*": "const char* ${in_value} = (*va_arg(args, QString*)).toStdString().c_str()"
    "kmMat4": "kmMat4 ${in_value} = to_mat4(*va_arg(args, QMatrix4x4*))"
    # object: "${ntype} ${out_value} = (${ntype})cx->top()"

  from_native:
    # from native to binding
    "@Point": "QPointF ${out_value} = convert_point(${in_value})"
    "@Rect": "QRectF ${out_value} = convert_rect(${in_value})"
    "@Size": "QSizeF ${out_value} = convert_size(${in_value})"
    "@Color4B": "QColor ${out_value} = convert_color4B(${in_value})"
    "@Color4F": "QColor ${out_value} = convert_color4F(${in_value})"
    "@Color3B": "QColor ${out_value} = convert_color3B(${in_value})"
    "@std::string": "QString ${out_value} = QString::fromStdString(${in_value})"
    "char*": "QString ${out_value}(${in_value})"
    "kmMat4": "QMatrix4x4 ${out_value} = convert_mat4(${in_value})"
    "kmVec3": "QVector3D ${out_value} = convert_vec3(${in_value})"
    # "Array*": "${out_value} = ccarray_to_jsval(cx, ${in_value})"
    # "Dictionary*": "${out_value} = ccdictionary_to_jsval(cx, ${in_value})"
    # "AffineTransform": "${out_value} = ccaffinetransform_to_jsval(cx, ${in_value})"
    # "FontDefinition": "${out_value} = FontDefinition_to_jsval(cx, ${in_value})"
    # "String*": "${out_value} = std_string_to_jsval(cx, ${in_value}->getCString())"
    "@.*Vector<.*>.*": "QList<tObjectPtr> ${out_value} = convert_vector(${in_value})"
    # "@Map<std::basic_string.*>": "cx->push((void*)&ret)"
    # "Value": "cx->push((void*)&ret)"
    # "ValueMap": "cx->push((void*)&ret)"
    # "ValueMapIntKey": "cx->push((void*)&ret)"
    # "ValueVector": "cx->push((void*)&ret)"
    # "@vector<std::basic_string.*>": "cx->push((void*)&ret)"
    # "@vector<int.*>": "cx->push((void*)ret)"
    # object: "cx->push((void*)ret)"
